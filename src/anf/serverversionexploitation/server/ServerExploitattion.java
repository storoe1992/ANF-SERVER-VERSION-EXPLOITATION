/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package anf.serverversionexploitation.server;


import anf.serverversionexploitation.util.PropertiesUtil;
import anf.serverversionexploitation.util.UpdateXMLUtil;
import io.vertx.core.AbstractVerticle;

import io.vertx.core.buffer.Buffer;
import io.vertx.core.file.AsyncFile;
import io.vertx.core.file.FileSystem;
import io.vertx.core.file.OpenOptions;
import io.vertx.core.http.HttpServer;

import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.json.JsonObject;


import io.vertx.core.streams.Pump;
import java.io.File;


import java.util.List;



/**
 *
 * @author Sergio
 */
public class ServerExploitattion  extends AbstractVerticle{
    

    
    
   public void start(){
      /* HttpServerOptions options= new HttpServerOptions().setKeyStoreOptions(
               new JksOptions()
                       .setPath("server.jks")
                       .setPassword("anfupdatereleaser"));*/
       String ip = PropertiesUtil.getInstance().getProperties().getProperty("server-ip-for-server-exploitation");
       int port = Integer.valueOf(PropertiesUtil.getInstance().getProperties().getProperty("server-port-for-server-exploitation"));
       HttpServer server = vertx.createHttpServer();
       
        server.requestHandler(req -> {
        
        String typeRequest = req.getParam("type");
        switch (typeRequest){
            case "file": functionReceiveFiles(req);break;
            case "json": functionReceiveJson(req);break;
            case "are you there": req.response().end();break;
                default: req.response().end();break;
        }
      
     
    
        
        }).listen(port,ip,res->{if(res.succeeded()){System.out.println("System online on: " + ip + " " + port );}});
  }    
   
   
   private void functionReceiveFiles(HttpServerRequest req){
      req.pause();
      String nameFile = req.getParam("filename");
      String rootPath = req.getParam("rootpath");
      String tempPath = req.getParam("uuid");
      String version = req.getParam("version");
      FileSystem fs = vertx.fileSystem();
      String finalTempPath = tempPath + File.separator +version + File.separator+ "files" + File.separator +rootPath; 
     /* fs.existsBlocking(tempPath);
      if(!fs.existsBlocking(versionTempPath))
          fs.mkdirBlocking(versionTempPath);*/
     
          fs.mkdirsBlocking(finalTempPath);
      
     // System.out.println(finalTempPath + File.separator + nameFile);
       fs.open(finalTempPath + File.separator + nameFile, new OpenOptions(), ares -> {
        AsyncFile file = ares.result();
        Pump pump = Pump.pump(req, file);
        req.endHandler(v1 -> file.close(v2 -> {
          //System.out.println("Uploaded to " + nameFile);
          
          req.response().end();
        }));
        pump.start();
        req.resume();
      });
   }
   
   private void functionReceiveJson(HttpServerRequest req){
       JsonObject temp = new JsonObject();
       //req.resume();
      /* FileSystem fs = vertx.fileSystem();
        String tempPath = req.getParam("uuid");
        if(!fs.existsBlocking(tempPath))
            fs.mkdirBlocking(tempPath);*/
       
       req.bodyHandler(buffer_total->{
           temp.readFromBuffer(0, buffer_total);
           switch (temp.getString("type")){
               case "configVersioXMLFile":fuctionReceiveJsonVersionXML(temp,req);break;
               case "finalTransfer" :  functionReceiveJsonFinalTransfer(temp,req);break;
               case "projectInfo" : functionReceiveJsonProjectInfo(temp,req);break;
                   default:System.out.println("No json message available");break;
                       
           }
           //req.response().end();
       
       });
       
   }
   
   private void fuctionReceiveJsonVersionXML(JsonObject configVersionXML, HttpServerRequest req){
       
       String tempPath = req.getParam("uuid");
       String version = req.getParam("version");
       String versionTempPath = tempPath + File.separator + version;
       FileSystem fs = vertx.fileSystem();
       if(!fs.existsBlocking(versionTempPath)){
        fs.mkdirsBlocking(versionTempPath);
       }
        byte [] file = configVersionXML.getBinary("file");
      Buffer buffer = Buffer.buffer(file);
      fs.writeFile(versionTempPath + File.separator + "config.xml", buffer, res ->{
      if(res.succeeded()){req.response().end();}
      });
      
   }
   
   public void functionReceiveJsonFinalTransfer(JsonObject item,HttpServerRequest req){
        //System.out.println("Final transfer arrive");
        String uuid = req.getParam("uuid");
        
        FileSystem fs = vertx.fileSystem();
        fs.readFile(uuid + File.separator + "projectinfo.json" , res->{
            if(res.succeeded()){
                Buffer buffer = res.result();
                JsonObject json = new JsonObject();
                json.readFromBuffer(0, buffer);
                String projectName = json.getString("projectName");
                String projectId = json.getString("projectId");
               // String projectVersion = json.getString("version");
                //System.out.println("server: ServerExploitation: functionReceiveJsonFinalTransfer: projectName:" + projectName+ " " + projectId + " " + projectVersion);
                moveVersions(uuid,projectName,projectId,req,buffer);
                
            }else {System.out.println("Fallo en leer la informacion del proyecto");}
        });
       
        
        
   }
   
   private void functionReceiveJsonProjectInfo(JsonObject temp,HttpServerRequest req){
       String uuid = req.getParam("uuid");
       FileSystem fs = vertx.fileSystem();
       fs.existsBlocking(uuid);
       Buffer buffer = Buffer.buffer();
       temp.writeToBuffer(buffer);
       fs.writeFile(uuid + File.separator + "projectinfo.json", buffer, res->{
           if(res.succeeded()){
               
               req.response().end();
           }
               
               });
   }
   
   private void moveVersions(String uuid, String projectName,String projectId,HttpServerRequest req,Buffer buffer){
       FileSystem fs = vertx.fileSystem();
       String rootPath = PropertiesUtil.getInstance().getRootDatas();
       String pathToProjects = rootPath + File.separator + projectName + File.separator +"versions";
       fs.mkdirsBlocking(pathToProjects);
       moveVersionAfterCheck(uuid, pathToProjects, projectId, projectName, buffer, req);
       
       //fs.moveBlocking(uuid, pathToProjects);
            
   }
       
   private void moveVersionAfterCheck(String uuid,String pathToProjects,String projectId,String projectName,Buffer buffer,HttpServerRequest req){
       FileSystem fs = vertx.fileSystem();
        List<String>listSources = fs.readDirBlocking(uuid);
        //System.out.println("server: ServerExplitation: moveVersionAfterCheck: fs.readDirBlocking(uuid):" + fs.readDirBlocking(uuid));
         String lastVersion = UpdateXMLUtil.lastVersionReleased(projectName);
       for(String source: listSources){
           File sources = new File(source);
           String fileFolderName = source.substring(source.lastIndexOf(File.separator));
           
           File destination = new File(pathToProjects+File.separator+fileFolderName);
           
           
        /* try {
                   
                   Files.move(sources.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);
               } catch (IOException ex) {
                   Logger.getLogger(ServerExploitattion.class.getName()).log(Level.SEVERE, null, ex);
                   
               }*/
          
          
           fs.exists(destination.toPath().toString(), res->{
              if(res.result()){
                   fs.deleteRecursive(destination.toPath().toString(),true,resultDelete->{
                       if(resultDelete.succeeded()){
                            fs.move(sources.toPath().toString(), destination.toPath().toString(),resultMove->{
                                if(resultMove.succeeded()){
                                    UpdateXMLUtil.makeJumps(projectName, lastVersion);
                                }
                            });
                       }
                   });
                  
                   }
              else{
                 fs.move(sources.toPath().toString(), destination.toPath().toString(),resultMove->{
                     if(resultMove.succeeded()){
                         UpdateXMLUtil.makeJumps(projectName, lastVersion);
                     }
                 
                 }); 
              }
           });
       }   
               
       vertx.setPeriodic(2000, id->{
           fs.delete(uuid, res->{
          if(res.succeeded()){
               UpdateXMLUtil.addOrNotProjectToProjectXML(projectId, projectName);
                req.response().end(buffer);
                vertx.cancelTimer(id);
                System.out.println("delete ok for: " + projectName + " on " + uuid);
          }else{
              System.out.println("cant delete yet for: "  + projectName + " on " + uuid);
          }
           
                   });
       
       });
       
       
               
          
           
       
       
       
       
   }
       
   }
   
   
   
