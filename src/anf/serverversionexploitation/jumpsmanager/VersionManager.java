/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package anf.serverversionexploitation.jumpsmanager;


import anf.serverversionexploitation.util.GeneralUtils;
import anf.serverversionexploitation.util.PropertiesUtil;
import java.io.File;
import java.io.InputStream;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.regex.Pattern;

/**
 * Obtiene informacion a partir de una versión actual especificada. Se comunica
 * con las clases necesarias para obtener el XML con los parámetros de
 * actualización necesarios.
 *
 * @author Jordy
 */
public class VersionManager implements Comparator<File> {

    private LinkedList<File> cacheFiles = new LinkedList<>();

    private final String appName;

    public VersionManager(String appName) {
        this.appName = appName;
    }

    private synchronized void notifyCache() {
        File datas = new File(PropertiesUtil.getInstance().getRootDatas() + this.appName + "/versions/");
        File[] vers = datas.listFiles();
        if (vers.length != cacheFiles.size()) {
            cacheFiles = new LinkedList<>();
            for (File f : vers) {
                if (f.isDirectory() && !f.isHidden() && f.getName().startsWith("v")) {
                    if(GeneralUtils.hasChildNamed(f, "config.xml"))
                    cacheFiles.add(f);
                }
            }
//            cacheFiles.addAll(Arrays.asList(vers));
            cacheFiles.sort(this);
        }
    }

//    /**
//     * Obtiene el valor de la última versión disponible.
//     *
//     * @param appName
//     * @return
//     */
//    public static int getLatestVersion(String appName) {
//        return getVersionValueOf(getPrintableLatestVersion(appName));
//    }
    /**
     * Devuelve la versión en un formato imprimible, o sea, convertido a cadena
     * de caracteres.
     *
     * @param appName
     * @return
     */
    public static String getPrintableLatestVersion(String appName) {
        File datas = new File(PropertiesUtil.getInstance().getRootDatas() + appName + "/versions/");
       // System.out.println("datas:  " + PropertiesUtil.getInstance().getRootDatas() + appName + "/versions/");
        File[] vers = datas.listFiles();
        LinkedList<File> cache = new LinkedList<>();
        for (File f : vers) {
            if (f.isDirectory() && !f.isHidden() && f.getName().startsWith("v")) {
                if(GeneralUtils.hasChildNamed(f, "config.xml"))
                    cache.add(f);
            }
        }
        cache.sort(new Comparator<File>() {
            @Override
            public int compare(File o1, File o2) {
//                int v1 = getVersionValueOf(o1.getName());
//                int v2 = getVersionValueOf(o2.getName());
//                if (v1 < v2) {
//                    return -1;
//                }
//                if (v1 > v2) {
//                    return 1;
//                }
//                return 0;
                return compareVersions(o1.getName(), o2.getName());
            }
        });
        File last = cache.getLast();
        return last.getName().substring(1);
    }

    /**
     * Devuelve el XML con las especificaciones necesarias para que el cliente
     * sepa que archivos debe realmente descargar con el objetivo de actualizar
     * a la última versión.
     *
     * @param currentVersion
     * @return
     * @throws Exception
     */
    public synchronized InputStream getXMLToLatestVersion(String currentVersion) throws Exception {
        notifyCache();
        VersionJump jump = new VersionJump(this.appName, currentVersion);
        InputStream res = jump.getCachedJump();
        if (res == null) {
            for (File f : cacheFiles) {
                if (isVersionALessEqualThanB(currentVersion, f.getName())) {
                    jump.processXML(getXMLInsideVersionFolder(f));
                }
            }
            res = jump.generateXML();
        }

        return res;
    }

    private File getXMLInsideVersionFolder(File folder) {

        File[] vers = folder.listFiles();
        for (File f : vers) {
            if (f.getName().equalsIgnoreCase("config.xml")) {
                return f;
            }
        }

        return null;
    }

    /**
     * Dado una versión cuyo valor es una cadena de caracteres se devuelve un
     * valor asociado a la versión. Ejemplo, sea la versión = "v2.3.0" entonces
     * el resultado es 230000
     *
     * @param version
     * @return
     */
    public static boolean isVersionALessEqualThanB(String versionA, String versionB) {
            if (compareVersions(versionA, versionB) <= 0) {
            return true;
        }
        return false;
    }
//    public static int getVersionValueOf(String version) {
//        int v = 0;
//        String cv = version.startsWith("v") ? version.substring(1) : version;
//        String[] versions = cv.split("\\.");
//        int cant = versions.length;
//        if (cant != 4) {
//            cant = 4;
//        }
//        int mult = (int) Math.pow(100, cant);
//        for (String part : versions) {
//            v += mult * Integer.valueOf(part);
//            mult /= 1000;
//        }
//        return v;
//    }

    @Override
    public int compare(File o1, File o2) {
        return compareVersions(o1.getName(), o2.getName());
    }

//    @Override
//    public int compare(File o1, File o2) {
//        int v1 = getVersionValueOf(o1.getName());
//        int v2 = getVersionValueOf(o2.getName());
//        if (v1 < v2) {
//            return -1;
//        }
//        if (v1 > v2) {
//            return 1;
//        }
//        return 0;
//    }


    private static int compareVersions(String v1, String v2) {
        String cv1 = v1.startsWith("v") ? v1.substring(1) : v1;
        String cv2 = v2.startsWith("v") ? v2.substring(1) : v2;
        String s1 = normalisedVersion(cv1);
        String s2 = normalisedVersion(cv2);
//        System.out.println("s1: " + s1);
//        System.out.println("s2: " + s2);
        int cmp = s1.compareTo(s2);
        return cmp;
    }

    public static String normalisedVersion(String version) {
        return normalisedVersion(version, ".", 4);
    }

    public static String normalisedVersion(String version, String sep, int maxWidth) {
        String[] split = Pattern.compile(sep, Pattern.LITERAL).split(version);
        StringBuilder sb = new StringBuilder();
        for (String s : split) {
            sb.append(String.format("%" + maxWidth + 's', s));
        }
        return sb.toString();
    }

        public static void main(String[] args) {
//        System.out.println(getVersionValueOf("17.5.1"));
//        System.out.println(getVersionValueOf("70.1"));
//        System.out.println(getVersionValueOf("2.999.999"));
//        System.out.println(getVersionValueOf("2.2.999"));
       // System.out.println("" + compareVersions("2.1.", "1.1"));
        //System.out.println("" + compareVersions("1.0.1", "1.1"));
       // System.out.println("" + compareVersions("1.9", "1.10"));
        //System.out.println("" + compareVersions("1.0.99999", "1.9"));
    }
    
}
